### 引入
> 在处理数组区间问题时，我们有两个强大的基础工具：前缀和与差分。

面对静态数组的区间求和，前缀和是当之无愧的王者。它通过 O(N) 预处理，能实现 O(1) 的闪电查询。但它的王朝建立在“数据不变”的基石之上。一旦引入单点修改，为了维护前缀和数组，每次修改都需要 O(N) 的代价，这在频繁更新的场景下是不可接受的。

另一边，当我们面临区间批量修改时，差分数组则大放异彩。它能以 O(1) 的惊人效率完成区间增减。然而，它的软肋也同样明显：当我们需要查询某个点或区间的具体值时，必须通过 O(N) 的计算来还原数据，这使得查询成为了性能瓶颈。

我们陷入了一个两难的境地：

- 前缀和：查询快，修改慢。
- 差分数组：修改快，查询慢。

> 难道就没有一种数据结构，能在这两者之间取得完美的平衡吗？

当然有。为了打破这种“鱼与熊掌不可兼得”的僵局，我们需要请出今天的主角——线段树。它是一种优雅的树形结构，能够将修改和查询的时间复杂度都优化到 O(log N) 级别，成为处理动态区间问题的全能选手。


### 线段树主体
线段树采取""粒度的分离与合并""的方式来管理区间信息，这么说有点抽象，下面展示一张线段树的图，以区间和为例：

<img width="672" height="411" alt="Image" src="https://github.com/user-attachments/assets/ca89eb7b-7ad9-46f5-b5c9-d9c68fd5aba4" />

