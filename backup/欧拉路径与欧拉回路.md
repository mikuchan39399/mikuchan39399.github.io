---

### 基本概念
> **欧拉路径是指图中每条边恰好经过一次的路径**
> **欧拉回路是指途中每条边恰好经过一次的回路**
>也就是说欧拉回路是一种特殊的欧拉路径，起点和终点必须相同
这里有一些名词：

- 欧拉图指存在欧拉回路的图
- 半欧拉图指存在欧拉路径但不存在欧拉回路的图

### 判定条件
**对于无向图**

1. 存在欧拉回路的充要条件
    a. 所有边联通（**所有度不为0的顶点构成一个连通分量**）
    b. 所有顶点度数都为偶数
2. 存在欧拉路径的充要条件
    a. 所有边联通
    b. **所有顶点度数都为偶数或者恰好有两个顶点度数为奇数**
        如果所有顶点度数都为偶数，此时任何点都能作为起点
        反之两个度数为奇数的顶点将成为起点和终点

**对于有向图**

1. 存在欧拉回路的充要条件
    a. 所有边联通（**所有入度+出度不为0的顶点构成一个弱连通分量**）
    b. 每个顶点的入度出度相等
2. 存在欧拉路径的充要条件
    a. 所有边联通
    b. **每个顶点的入度出度相同或者入度大1和出度大1的点各存在一个**
    对于非欧拉回路情况时，起点为出度大1的点，终点为出度大1的点

### Hierholzer 算法
> Hierholzer 算法，⼜称逐步插⼊回路法求解，用于求解该问题
**算法流程：**
选择起始点 s ，然后 dfs。当递归到顶点 x 时：
• 遍历 x 的出边 (x → y) ：
    ◦ 删掉 (x → y) ；（如果是⽆向图，需要删正反两条边）
    ◦ 递归进 y ，做同样操作；
    ◦ 从 y 回溯，递归下⼀条边时，将边 (x → y) 加⼊答案数组；（如果结果要的是边的路线）
• 所有 x 的边都遍历完毕之后，将 x 顶点加⼊答案数组。（如果结果要的是顶点的路线）
最终将答案数组逆序，就是欧拉路径。
如果需要按照字典序输出欧拉路径，仅需在遍历所有出边的时候，按照顶点编号从⼩到⼤遍历即可
**这里最好用vector邻接表存图，这样从大到小排序并且用尾删就能实现O(1)的复杂度**

```cpp
void dfs(int u) 
{
    while (edges[u] is not empty) 
    {
      let (v, edge_id) be the last edge in edges[u];
      remove this edge from edges[u]; 
      // 如果是无向图，标记边为已访问，而不是真的删除另外一条边
      dfs(v);
      path.push(edge_id); // 根据需要记录边或点
    }
   path.push(u) //记录点
}
```

[模板链接](https://github.com/mikuchan39399/HNIST-ACM-2024/tree/main/algorithms/%E5%9B%BE%E8%AE%BA/%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84%E4%B8%8E%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF)

### 例题
[例题源码链接](https://github.com/mikuchan39399/HNIST-ACM-2024/tree/main/algorithms/%E5%9B%BE%E8%AE%BA/%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84%E4%B8%8E%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/%E4%BE%8B%E9%A2%98)

#### 
---
