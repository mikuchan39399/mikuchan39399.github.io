---

### 基本概念
> **欧拉路径是指图中每条边恰好经过一次的路径**
> **欧拉回路是指途中每条边恰好经过一次的回路**
>也就是说欧拉回路是一种特殊的欧拉路径，起点和终点必须相同
这里有一些名词：

- 欧拉图指存在欧拉回路的图
- 半欧拉图指存在欧拉路径但不存在欧拉回路的图

### 判定条件
**对于无向图**

1. 存在欧拉回路的充要条件
    a. 所有边联通（**所有度不为0的顶点构成一个连通分量**）
    b. 所有顶点度数都为偶数
2. 存在欧拉路径的充要条件
    a. 所有边联通
    b. **所有顶点度数都为偶数或者恰好有两个顶点度数为奇数**
        如果所有顶点度数都为偶数，此时任何点都能作为起点
        反之两个度数为奇数的顶点将成为起点和终点

**对于有向图**

1. 存在欧拉回路的充要条件
    a. 所有边联通（**所有入度+出度不为0的顶点构成一个弱连通分量**）
    b. 每个顶点的入度出度相等
2. 存在欧拉路径的充要条件
    a. 所有边联通
    b. **每个顶点的入度出度相同或者入度大1和出度大1的点各存在一个**
    对于非欧拉回路情况时，起点为出度大1的点，终点为出度大1的点

### Hierholzer 算法
> Hierholzer 算法，⼜称逐步插⼊回路法求解，用于求解该问题
**算法流程：**
选择起始点 s ，然后 dfs。当递归到顶点 x 时：
• 遍历 x 的出边 (x → y) ：
    ◦ 删掉 (x → y) ；（如果是⽆向图，需要删正反两条边）
    ◦ 递归进 y ，做同样操作；
    ◦ 从 y 回溯，递归下⼀条边时，将边 (x → y) 加⼊答案数组；（如果结果要的是边的路线）
• 所有 x 的边都遍历完毕之后，将 x 顶点加⼊答案数组。（如果结果要的是顶点的路线）
最终将答案数组逆序，就是欧拉路径。
如果需要按照字典序输出欧拉路径，仅需在遍历所有出边的时候，按照顶点编号从⼩到⼤遍历即可
**这里最好用vector邻接表存图，这样从大到小排序并且用尾删就能实现O(1)的复杂度**

```cpp
void dfs(int u) 
{
    while (edges[u] is not empty) 
    {
      let (v, edge_id) be the last edge in edges[u];
      remove this edge from edges[u]; 
      // 如果是无向图，标记边为已访问，而不是真的删除另外一条边
      dfs(v);
      path.push(edge_id); // 根据需要记录边或点
    }
   path.push(u) //记录点
}
```

[模板链接](https://github.com/mikuchan39399/HNIST-ACM-2024/tree/main/algorithms/%E5%9B%BE%E8%AE%BA/%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84%E4%B8%8E%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF)

### 例题
[例题源码链接](https://github.com/mikuchan39399/HNIST-ACM-2024/tree/main/algorithms/%E5%9B%BE%E8%AE%BA/%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84%E4%B8%8E%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF/%E4%BE%8B%E9%A2%98)

#### P1341 无序字母对
[传送门](https://www.luogu.com.cn/problem/P1341)

> 把每个字母都看作一个图中的节点，每个字母对看作图中的一条边，因为字母对可以让我们从一个字母到达另一个字母，因为字母对无序所以这个图是无向图。
> 题目要求每个字母对需要相邻，并且输出一个字母对数量+1个字母的字符串，要求每个字母对都在这个字符串里出现，也就是每条边都在点路径序列中出现，因为字符串数量限制每条边必须恰好出现一次，这不就是欧拉路径吗。
> 注意字典序，答案要求点序列和无向图，还有把字母偏移成1~n之后，注意有可能某些字母没有出现过，注意递归起点


#### P1127 词链
[传送门](https://www.luogu.com.cn/problem/P1127)

> 可以把每个单词看成一条边，可以让我们从单词首字母到达末尾字母，因为用小点连接的两个单词的末尾字母和首字母必须要相等，很明显单词不能反正来，所以这是一个有向图。
> 题目中说每个单词必须恰好出现一次，所以又是欧拉路径。
> 注意题目要求答案输出单词序列，所以存边的时候需要存相邻节点编号和边代表的单词


#### P1333 瑞瑞的木棍
[传送门](https://www.luogu.com.cn/problem/P1333)

> 这题的字符串代表节点，用unordered_map为其分配编号即可
> 剩下的就是无向图判断欧拉路径的逻辑
> 题目不要求输出路径所以判断是否存在欧拉路径只需要用并查集判断所有边是否联通即可


#### P3520 [POI 2011] SMI-Garbage
[传送门](https://www.luogu.com.cn/problem/P3520)

> 符合要求的边的垃圾车经过次数位偶数，不符的边垃圾车经过次数为奇数
> 因为某些神秘逻辑偶数边可以直接删掉（贪心吗？因为奇数边经过一次，比两次要小），奇数边经过一次即可
> 注意到每一辆垃圾车的路径，也就是回路上的点除了起点只能经过一次，所以这题不求欧拉回路而是把每个子回路都统计出来，在模板逻辑中使用栈稍加模拟即可，具体看代码
> 因为题目描述的图可能不连通，所以要进行多次dfs
---
