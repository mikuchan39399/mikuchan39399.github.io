---

### 基本概念
> 欧拉路径是指图中每条边恰好经过一次的路径
> 欧拉回路是指途中每条边恰好经过一次的回路
>也就是说欧拉回路是一种特殊的欧拉路径，起点和终点必须相同
这里有一些名词：

- 欧拉图指存在欧拉回路的图
- 半欧拉图指存在欧拉路径但不存在欧拉回路的图

### 判定条件
**对于无向图**

1. 存在欧拉回路的充要条件
    a. 所有边联通
    b. 所有顶点度数都为偶数
2. 存在欧拉路径的充要条件
    a. 所有边联通
    b. **所有顶点度数都为偶数或者恰好有两个顶点度数为奇数**
        如果所有顶点度数都为偶数，此时任何点都能作为起点
        反之两个度数为奇数的顶点将成为起点和终点

**对于有向图**

1. 存在欧拉回路的充要条件
    a. 所有的边联通
    b. 每个顶点的入度出度相等
2. 存在欧拉路径的充要条件
    a. 所有边联通
    b. **每个顶点的入度出度相同或者入度大1和出度大1的点各存在一个**
    对于非欧拉回路情况时，起点为出度大1的点，终点为出度大1的点

### Hierholzer 算法
> Hierholzer 算法，⼜称逐步插⼊回路法求解，用于求解该问题
**算法流程**
选择起始点 s ，然后 dfs。当递归到顶点 x 时：
• 遍历 x 的出边 (x → y) ：
    ◦ 删掉 (x → y) ；（如果是⽆向图，需要删正反两条边）
    ◦ 递归进 y ，做同样操作；
    ◦ 从 y 回溯，递归下⼀条边时，将边 (x → y) 加⼊答案数组；（如果结果要的是边的路线）
• 所有 x 的边都遍历完毕之后，将 x 顶点加⼊答案数组。（如果结果要的是顶点的路线）
最终将答案数组逆序，就是欧拉路径。
如果需要按照字典序输出欧拉路径，仅需在遍历所有出边的时候，按照顶点编号从⼩到⼤遍历即可
```cpp
void dfs(int x) //伪代码，需要注意的是最好用vector存图
{
  for(auto y : edges[x]) // 遍历所有出边
  {
    delete(x->y); // 删除这条边
    dfs(y); // 进⼊下⼀个节点
    // 如果要的是边的路线
    ret.push(x->y);
  }
ret.push(x); // 加⼊到结果中
}
```

[模板链接](https://github.com/mikuchan39399/HNIST-ACM-2024/tree/main/algorithms/%E5%9B%BE%E8%AE%BA/%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84%E4%B8%8E%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF)

### 例题
[例题源码链接]()

---
