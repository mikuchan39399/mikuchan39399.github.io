## 1 库
库是提供特定功能的，成熟的可复用的代码，printf 函数就是C语言的`标准库`函数，库的重要性不言而喻。
- 静态库 `Linux - .a`    `Windows - .lib`
- 动态库 `Linux - .so`  `Windows - .dll`

> [!Note]
> 库本质上也是一种可执行代码的二进制形式，可以被操作系统拉到内存中执行
### 1.1 静态库
静态库本质就是**一些可重定向文件的集合**，所以在操作系统看来一个可执行文件有没有使用静态库是没有任何影响的
> [!Note]
> 一个可执行程序可能混合依赖静态库和动态库，编译默认动态链接库，只有找不到对应动态库时才会静态链接同名静态库，gcc 的 -`-static`选项可以强制优先静态链接静态库
#### 生成静态库
1. 将 C 源码编译为目标文件  `gcc -c 源文件.c`
2. 使用 GNU 的归档工具 ar，将多个 .o 文件打包成一个文件  `ar -rc libmystdio.a my_stdio.o my_string.o`
3. 生成后可以使用 ar 工具查看库里面包含的 .o 文件  `ar -tv libmystdio.a`
- `-t`：显示压缩包/归档文件中的内容列表。
- `-v`：显示详细信息。
#### 使用静态库
若可执行程序依赖某个静态库，则需要在编译时指明：
- `-l` 指定库名，去掉文件后缀与`lib`前缀即为库名
- `-I` 指定头文件搜索路径
- `-L` 指定库路径
### 1.2 动态库
如果程序依赖动态库，则程序`运行时`需要链接动态库
- 在程序运行之前加载动态库进内存并使用页表映射的过程被称作`动态链接`
- 把动态库加载进内存只需要加载程序用到的其中函数的地址，而不是函数所在目标文件的所有机器码
- 若多个进程程序都需要使用同一动态库，相比于臃肿的静态库，动态库只需要被加载进物理内存一份，每个进程的页表自己去映射虚拟地址就行了，节省了内存空间
#### 生成动态库
1. 将 C 源码编译为“位置无关”的目标文件
   - `gcc -fPIC -c 源文件.c`
   - `-fPIC` 生成位置无关代码
2. 链接生成动态库
   - `gcc -o libmystdio.so my_stdio.o my_string.o -shared`
   - `-shared` 表示生成共享库格式，也就是动态库格式
3. 运行时搜索动态库目录
   - 拷⻉ `动态库` ⽂件到系统共享库路径下,⼀般指 `/usr/lib`、`/usr/local/lib`、`/lib64` 或者开篇指明的库路径等
   - 向**系统**动态库路径下提供库同名软链接
   - 更改 `LD_LIBRARY_PATH` 环境变量
## 2. ELF文件
以下四种文件皆为`ELF`格式文件
- 可重定位文件/目标文件 `xxx.o`
- 可执行文件
- 动态库文件 `xxx.so`
- 内核转储
### 2.1 介绍ELF格式
```ascii
+----------------------------------+
|                                  |
|            ELF Header            |
|                                  |
+----------------------------------+
|                                  |
|    Program Header Table          |
|                                  |
+----------------------------------+
|                                  |
|            Section 1             |
|                                  |
+----------------------------------+
|                                  |
|            Section 2             |
|                                  |
+----------------------------------+
|                                  |
|               ...                |
|                                  |
+----------------------------------+
|                                  |
|            Section n             |
|                                  |
+----------------------------------+
|                                  |
|       Section Header Table       |
|                                  |
+----------------------------------+
```
` ELF Header` 中存储着整个ELF文件的相关信息，文件类型，机器类型，版本，`入口地址`，节头表与段头表的位置与大小等等
可以用`readelf -h xxx` 来查看一个ELF文件的文件头信息

<img width="939" height="558" alt="Image" src="https://github.com/user-attachments/assets/c1ea4ee4-743e-465e-95e6-d03332600234" />

### 2.2 节头表
将多个目标文件链接成可执行文件的过程需要节头表
也就是说编译器在链接时需要节头表以合并这些目标文件的节
**什么是节？**
还记得程序地址空间的内容吗？
- `.text`节 - 存放可执行的指令/代码
- `.data`节 - 存放已初始化的全局变量
- `.bss`节 - 存放未初始化的全局变量
- `.rodata` 节 - 存放只读数据区，例如字符串常量
这种细致的分类，让链接可以方便地合并不同的目标文件，合并同类型的节
`readelf -S a.out` 可用来查看可执行程序的节
```
whf@iZ7xvhr9e4wz4wpzicdcfgZ:~/workstaff/linux1/system_part/template$ readelf -S a
There are 31 section headers, starting at offset 0x39a8:

节头：
  [号] 名称              类型             地址              偏移量
       大小              全体大小          旗标   链接   信息   对齐
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .interp           PROGBITS         0000000000000318  00000318
       000000000000001c  0000000000000000   A       0     0     1
  [ 2] .note.gnu.pr[...] NOTE             0000000000000338  00000338
       0000000000000030  0000000000000000   A       0     0     8
  [ 3] .note.gnu.bu[...] NOTE             0000000000000368  00000368
       0000000000000024  0000000000000000   A       0     0     4
  [ 4] .note.ABI-tag     NOTE             000000000000038c  0000038c
       0000000000000020  0000000000000000   A       0     0     4
  [ 5] .gnu.hash         GNU_HASH         00000000000003b0  000003b0
       0000000000000028  0000000000000000   A       6     0     8
  [ 6] .dynsym           DYNSYM           00000000000003d8  000003d8
       0000000000000120  0000000000000018   A       7     1     8
  [ 7] .dynstr           STRTAB           00000000000004f8  000004f8
       000000000000016c  0000000000000000   A       0     0     1
  [ 8] .gnu.version      VERSYM           0000000000000664  00000664
       0000000000000018  0000000000000002   A       6     0     2
  [ 9] .gnu.version_r    VERNEED          0000000000000680  00000680
       0000000000000070  0000000000000000   A       7     2     8
  [10] .rela.dyn         RELA             00000000000006f0  000006f0
       00000000000000d8  0000000000000018   A       6     0     8
  [11] .rela.plt         RELA             00000000000007c8  000007c8
       0000000000000060  0000000000000018  AI       6    24     8
  [12] .init             PROGBITS         0000000000001000  00001000
       000000000000001b  0000000000000000  AX       0     0     4
  [13] .plt              PROGBITS         0000000000001020  00001020
       0000000000000050  0000000000000010  AX       0     0     16
  [14] .plt.got          PROGBITS         0000000000001070  00001070
       0000000000000010  0000000000000010  AX       0     0     16
  [15] .plt.sec          PROGBITS         0000000000001080  00001080
       0000000000000040  0000000000000010  AX       0     0     16
  [16] .text             PROGBITS         00000000000010c0  000010c0
       000000000000026e  0000000000000000  AX       0     0     16
  [17] .fini             PROGBITS         0000000000001330  00001330
       000000000000000d  0000000000000000  AX       0     0     4
  [18] .rodata           PROGBITS         0000000000002000  00002000
       0000000000000023  0000000000000000   A       0     0     4
  [19] .eh_frame_hdr     PROGBITS         0000000000002024  00002024
       0000000000000054  0000000000000000   A       0     0     4
  [20] .eh_frame         PROGBITS         0000000000002078  00002078
       0000000000000130  0000000000000000   A       0     0     8
  [21] .init_array       INIT_ARRAY       0000000000003d90  00002d90
       0000000000000008  0000000000000008  WA       0     0     8
  [22] .fini_array       FINI_ARRAY       0000000000003d98  00002d98
       0000000000000008  0000000000000008  WA       0     0     8
  [23] .dynamic          DYNAMIC          0000000000003da0  00002da0
       0000000000000200  0000000000000010  WA       7     0     8
  [24] .got              PROGBITS         0000000000003fa0  00002fa0
       0000000000000060  0000000000000008  WA       0     0     8
  [25] .data             PROGBITS         0000000000004000  00003000
       0000000000000010  0000000000000000  WA       0     0     8
  [26] .bss              NOBITS           0000000000004040  00003010
       0000000000000118  0000000000000000  WA       0     0     64
  [27] .comment          PROGBITS         0000000000000000  00003010
       000000000000002b  0000000000000001  MS       0     0     1
  [28] .symtab           SYMTAB           0000000000000000  00003040
       0000000000000498  0000000000000018          29    21     8
  [29] .strtab           STRTAB           0000000000000000  000034d8
       00000000000003b2  0000000000000000           0     0     1
  [30] .shstrtab         STRTAB           0000000000000000  0000388a
       000000000000011a  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), l (large), p (processor specific)
```
### 2.3 程序头表
操作系统在加载时，如果按照最小单位为节去分配内存的话，我们知道操作系统内存管理与磁盘IO的最小单位为`4KB`，这样会极大地浪费内存，所以操作系统在把ELF文件拉进内存时还会做进一步合并成**段**，这个过程需要用到程序头表
**什么是段？**
当程序运行时，操作系统并不关心这块数据具体是全局变量还是字符串常量，它只关心这块内存的访问权限。
- 可读吗？
- 可写吗？
- 可执行吗？
所以，一个段是由一个或者多个具有相同访问权限的节合并的，合并同类项，比如：
- 比如，`.text` 节（只读、可执行）和 `.rodata`节（只读）会被打包进同一个 `Text` 段（可读、可执行：R E）
- `.data` 节和 `.bss` 节会被打包进同一个 `Data` 段（可读、可写：R W）。
程序头表在链接器合并完节后顺手根据访问权限生成程序头表，指导操作系统以段加载ELF进内存


## 3. 深入链接与加载
### 3.1 逻辑地址
进程`mm_struct`->`vm_area_struct`在进程刚刚创建的时候，初始化数据从哪⾥来的？
- 我们可以用`objdump -S`反汇编一下可执行文件
```
whf@iZ7xvhr9e4wz4wpzicdcfgZ:~/workstaff/linux1/system_part/template$  objdump -S a

a：     文件格式 elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:       f3 0f 1e fa             endbr64
    1004:       48 83 ec 08             sub    $0x8,%rsp
    1008:       48 8b 05 e1 2f 00 00    mov    0x2fe1(%rip),%rax        # 3ff0 <__gmon_start__@Base>
    100f:       48 85 c0                test   %rax,%rax
    1012:       74 02                   je     1016 <_init+0x16>
    1014:       ff d0                   call   *%rax
    1016:       48 83 c4 08             add    $0x8,%rsp
    101a:       c3                      ret
......
```
我们会发现一个ELF文件在被加载进内存之前就已经拥有虚拟地址了，就是最左边那一列
我们把ELF中的虚拟地址称作**逻辑地址/偏移量**，这与后面要讲的`PIC`位置无关代码关系很大
回答开篇的问题：操作系统在加载程序时，会解析 ELF 文件中的程序头表。程序头表中详细记录了各个**段**的预期逻辑地址、长度以及访问权限。

操作系统正是提取了这些段信息，来实例化并初始化进程的 vm_area_struct 结构体。
> [!Note]
> 所以虚拟地址这个概念需要操作系统与编译器互相协同支持
### 3.2 CPU硬件支持虚拟地址
在操作系统把ELF可执行文件加载进内存之后，应该交由CPU执行程序，而所有ELF文件全都是逻辑地址编址过的，也就是说CPU也要支持虚拟地址
- CPU中有着这两个寄存器：
   - `EIP` 程序计数器
   - `CR3` 页目录基址寄存器
- 和一个CPU内部硬件模块`MMU`内存管理单元
1. `EIP`寄存器存放当前正在执行的指令的**下一条指令的虚拟地址**，CPU内部只认这个虚拟地址
2. `CR3`寄存器存放当前进程页表所在的物理地址
3. `MMU`会通过`CR3`寄存器找到当前进程页表读出`EIP`寄存器内虚拟地址对应的物理地址，然后把物理地址上的指令交给CPU执行
> [!important]
> 所以虚拟地址机制需要 操作系统 编译器 CPU硬件三方的支持才能运作
### 3.4 动态链接
程序执行的入口地址存在于ELF头中 - `Entry point address`
```cpp
#include <stdio.h>

int main()
{
    printf("I Like Miku!\n");
    return 0;
}
```
```
whf@iZ7xvhr9e4wz4wpzicdcfgZ:~/workstaff/linux1/system_part/mytest$ readelf -h run
ELF 头：
  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  类别:                              ELF64
  数据:                              2 补码，小端序 (little endian)
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI 版本:                          0
  类型:                              DYN (Position-Independent Executable file)
  系统架构:                          Advanced Micro Devices X86-64
  版本:                              0x1
  入口点地址：               0x1060
  程序头起点：          64 (bytes into file)
  Start of section headers:          13976 (bytes into file)
  标志：             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         13
  Size of section headers:           64 (bytes)
  Number of section headers:         31
  Section header string table index: 30
```
```
whf@iZ7xvhr9e4wz4wpzicdcfgZ:~/workstaff/linux1/system_part/mytest$ objdump -S run

run：     文件格式 elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:       f3 0f 1e fa             endbr64
    1004:       48 83 ec 08             sub    $0x8,%rsp
    1008:       48 8b 05 d9 2f 00 00    mov    0x2fd9(%rip),%rax        # 3fe8 <__gmon_start__@Base>
    100f:       48 85 c0                test   %rax,%rax
    1012:       74 02                   je     1016 <_init+0x16>
    1014:       ff d0                   call   *%rax
    1016:       48 83 c4 08             add    $0x8,%rsp
    101a:       c3                      ret

Disassembly of section .plt:

0000000000001020 <.plt>:
    1020:       ff 35 9a 2f 00 00       push   0x2f9a(%rip)        # 3fc0 <_GLOBAL_OFFSET_TABLE_+0x8>
    1026:       ff 25 9c 2f 00 00       jmp    *0x2f9c(%rip)        # 3fc8 <_GLOBAL_OFFSET_TABLE_+0x10>
    102c:       0f 1f 40 00             nopl   0x0(%rax)
    1030:       f3 0f 1e fa             endbr64
    1034:       68 00 00 00 00          push   $0x0
    1039:       e9 e2 ff ff ff          jmp    1020 <_init+0x20>
    103e:       66 90                   xchg   %ax,%ax

Disassembly of section .plt.got:

0000000000001040 <__cxa_finalize@plt>:
    1040:       f3 0f 1e fa             endbr64
    1044:       ff 25 ae 2f 00 00       jmp    *0x2fae(%rip)        # 3ff8 <__cxa_finalize@GLIBC_2.2.5>
    104a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)

Disassembly of section .plt.sec:

0000000000001050 <puts@plt>:
    1050:       f3 0f 1e fa             endbr64
    1054:       ff 25 76 2f 00 00       jmp    *0x2f76(%rip)        # 3fd0 <puts@GLIBC_2.2.5>
    105a:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)

Disassembly of section .text:

0000000000001060 <_start>:
    1060:       f3 0f 1e fa             endbr64
    1064:       31 ed                   xor    %ebp,%ebp
    1066:       49 89 d1                mov    %rdx,%r9
    1069:       5e                      pop    %rsi
    106a:       48 89 e2                mov    %rsp,%rdx
    106d:       48 83 e4 f0             and    $0xfffffffffffffff0,%rsp
    1071:       50                      push   %rax
    1072:       54                      push   %rsp
    1073:       45 31 c0                xor    %r8d,%r8d
    1076:       31 c9                   xor    %ecx,%ecx
    1078:       48 8d 3d ca 00 00 00    lea    0xca(%rip),%rdi        # 1149 <main>
    107f:       ff 15 53 2f 00 00       call   *0x2f53(%rip)        # 3fd8 <__libc_start_main@GLIBC_2.34>
    1085:       f4                      hlt
    1086:       66 2e 0f 1f 84 00 00    cs nopw 0x0(%rax,%rax,1)
    108d:       00 00 00 

0000000000001090 <deregister_tm_clones>:
    1090:       48 8d 3d 79 2f 00 00    lea    0x2f79(%rip),%rdi        # 4010 <__TMC_END__>
    1097:       48 8d 05 72 2f 00 00    lea    0x2f72(%rip),%rax        # 4010 <__TMC_END__>
    109e:       48 39 f8                cmp    %rdi,%rax
    10a1:       74 15                   je     10b8 <deregister_tm_clones+0x28>
    10a3:       48 8b 05 36 2f 00 00    mov    0x2f36(%rip),%rax        # 3fe0 <_ITM_deregisterTMCloneTable@Base>
    10aa:       48 85 c0                test   %rax,%rax
    10ad:       74 09                   je     10b8 <deregister_tm_clones+0x28>
    10af:       ff e0                   jmp    *%rax
    10b1:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)
    10b8:       c3                      ret
    10b9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)

00000000000010c0 <register_tm_clones>:
    10c0:       48 8d 3d 49 2f 00 00    lea    0x2f49(%rip),%rdi        # 4010 <__TMC_END__>
    10c7:       48 8d 35 42 2f 00 00    lea    0x2f42(%rip),%rsi        # 4010 <__TMC_END__>
    10ce:       48 29 fe                sub    %rdi,%rsi
    10d1:       48 89 f0                mov    %rsi,%rax
    10d4:       48 c1 ee 3f             shr    $0x3f,%rsi
    10d8:       48 c1 f8 03             sar    $0x3,%rax
    10dc:       48 01 c6                add    %rax,%rsi
    10df:       48 d1 fe                sar    $1,%rsi
    10e2:       74 14                   je     10f8 <register_tm_clones+0x38>
    10e4:       48 8b 05 05 2f 00 00    mov    0x2f05(%rip),%rax        # 3ff0 <_ITM_registerTMCloneTable@Base>
    10eb:       48 85 c0                test   %rax,%rax
    10ee:       74 08                   je     10f8 <register_tm_clones+0x38>
    10f0:       ff e0                   jmp    *%rax
    10f2:       66 0f 1f 44 00 00       nopw   0x0(%rax,%rax,1)
    10f8:       c3                      ret
    10f9:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)

0000000000001100 <__do_global_dtors_aux>:
    1100:       f3 0f 1e fa             endbr64
    1104:       80 3d 05 2f 00 00 00    cmpb   $0x0,0x2f05(%rip)        # 4010 <__TMC_END__>
    110b:       75 2b                   jne    1138 <__do_global_dtors_aux+0x38>
    110d:       55                      push   %rbp
    110e:       48 83 3d e2 2e 00 00    cmpq   $0x0,0x2ee2(%rip)        # 3ff8 <__cxa_finalize@GLIBC_2.2.5>
    1115:       00 
    1116:       48 89 e5                mov    %rsp,%rbp
    1119:       74 0c                   je     1127 <__do_global_dtors_aux+0x27>
    111b:       48 8b 3d e6 2e 00 00    mov    0x2ee6(%rip),%rdi        # 4008 <__dso_handle>
    1122:       e8 19 ff ff ff          call   1040 <__cxa_finalize@plt>
    1127:       e8 64 ff ff ff          call   1090 <deregister_tm_clones>
    112c:       c6 05 dd 2e 00 00 01    movb   $0x1,0x2edd(%rip)        # 4010 <__TMC_END__>
    1133:       5d                      pop    %rbp
    1134:       c3                      ret
    1135:       0f 1f 00                nopl   (%rax)
    1138:       c3                      ret
    1139:       0f 1f 80 00 00 00 00    nopl   0x0(%rax)

0000000000001140 <frame_dummy>:
    1140:       f3 0f 1e fa             endbr64
    1144:       e9 77 ff ff ff          jmp    10c0 <register_tm_clones>

0000000000001149 <main>:
    1149:       f3 0f 1e fa             endbr64
    114d:       55                      push   %rbp
    114e:       48 89 e5                mov    %rsp,%rbp
    1151:       48 8d 05 ac 0e 00 00    lea    0xeac(%rip),%rax        # 2004 <_IO_stdin_used+0x4>
    1158:       48 89 c7                mov    %rax,%rdi
    115b:       e8 f0 fe ff ff          call   1050 <puts@plt>
    1160:       b8 00 00 00 00          mov    $0x0,%eax
    1165:       5d                      pop    %rbp
    1166:       c3                      ret

Disassembly of section .fini:

0000000000001168 <_fini>:
    1168:       f3 0f 1e fa             endbr64
    116c:       48 83 ec 08             sub    $0x8,%rsp
    1170:       48 83 c4 08             add    $0x8,%rsp
    1174:       c3                      ret
```

可以看到`main`函数并不是一个可执行程序运行时真正的起点，`_start`函数才是起点
`_start`函数是C运行时库（比如`glibc`）或者链接器提供的特殊函数，它的功能有：
1. 为程序设置一个初始的堆栈环境
2. 将程序的数据段从初始化数据段复制到相应的内存位置，并清零未初始化的数据段。
3. **动态链接！** `_start` 函数会调⽤动态链接器的代码来解析和加载程序所依赖的动态库。动态链接器会处理所有的符号解析和重定位，确保程序中的函数调⽤和变量访问能够正确地映射到动态库中的实际地址。
4.  动态链接完成后，` _start` 函数会调⽤`__libc_start_main` （`glibc`提供）。 `__libc_start_main` 函数负责执⾏⼀些额外的初始化⼯作，⽐如设置信号处理函数、初始化线程库（如果使⽤了线程）等等
5. `__libc_start_main` 然后调用`main`函数
6.  `main`函数返回后，`__libc_start_main` 会处理这个返回值然后调用`_exit`系统调用终止程序
#### 位置无关代码 `PIC`
我们在前面提到过，动态库最大的优势是在物理内存中只有一份，被多个进程共享。
但这就带来了一个问题：每个进程的虚拟地址空间是独立的，动态库被加载到各个进程的虚拟地址（基地址）大概率是不同的。

如果我们在编译动态库时使用的是绝对地址，那么每次加载，操作系统都必须去修改代码段（`.text`）里的硬编码地址。这就破坏了代码段“只读”和“多进程共享”的初衷（因为一修改，根据写时复制机制，物理内存就会多出一份拷贝）。

如何解决？这就是 -fPIC 选项的作用。
PIC 的核心思想是：把代码段中需要被修改的绝对地址引用，剥离出来放到数据段中。
因为指令在内存中的相对位置是固定的。在 x86-64 架构下，CPU 极大地支持了这一点，也就是基于 %rip（指令指针寄存器）的相对寻址。代码段（`.text`）和数据段（`.data/.bss`）在同一个 ELF 文件里的相对偏移量是永远不变的，无论这个库被加载到虚拟内存的哪个位置。

#### 全局偏移量表 `GOT`
既然代码段不能被修改，那么程序在调用外部函数或者访问外部全局变量时，它去哪里找真实的绝对地址呢？
答案就是`GOT`（全局偏移量表）。

GOT 存在于数据段中（具体分为 .got 存放全局变量地址，.got.plt 存放外部函数地址）。

因为它在数据段，所以每个进程都有自己独立的一份 GOT 副本，操作系统可以随意修改它而不会影响其他进程。

它的本质是一个指针数组。表中的每一项都保存着一个外部符号在当前进程虚拟内存中的绝对真实地址。

运作机制：当代码需要调用外部函数时，它不会直接 call 绝对地址，而是利用基于 `%rip` 的相对寻址，找到自己进程数据段中的 GOT 表，从里面读出真实的函数地址再跳转。这个表的内容，是由动态链接器在程序加载或运行时填入的。
#### 过程链接表 `PLT`
我们之前的`main`函数里只有一个标准库函数`printf`
```
  115b:       e8 f0 fe ff ff          call   1050 <puts@plt>
```
这个`call`类型的汇编很明显就是编译后的`printf`函数，编译器优化成了`puts`函数，后面的`@plt`是什么玩意呢
理论上，有了 `PIC` 和 `GOT` 就足以完成动态链接了，代码直接去 GOT 里读地址就行。那为什么还要搞出一个 `PLT`（过程链接表）呢？
这主要是为了服务于接下来要讲的**延迟加载**机制。

PLT 存在于代码段中（`.plt` 节），也就是反汇编看到的 puts@plt。

它是一堆很小的“跳板”代码。

当我们在 C 语言里调用 `printf` 时，编译器实际上把它编译成了调用本程序内部的 printf@plt。
```
0000000000001050 <puts@plt>:
    1050:       f3 0f 1e fa             endbr64
    1054:       ff 25 76 2f 00 00       jmp    *0x2f76(%rip)        # 3fd0 <puts@GLIBC_2.2.5>
```
这其实就是在跳入 `GOT` 表（0x2f76(%rip) 算出来就是 GOT 表里存放 puts 地址的那个条目）。
#### 延迟加载
现代程序往往依赖庞大的动态库，里面有成千上万个函数。如果程序一启动，动态链接器就把所有函数的绝对地址都解析出来并填入 GOT 表，那程序的启动速度会非常慢。

实际上，程序运行一次通常只会用到其中的一小部分函数。所以，Linux 默认采用了**延迟加载**策略：只有当一个外部函数第一次被调用时，才去解析它的真实地址。

第一次调用（未解析）：
- 程序调用 puts@plt。

- PLT 里的 jmp 指令去查 GOT 表。

- 在第一次调用前，动态链接器在 GOT 表里填写的并不是 puts 的真实地址，而是 PLT 跳板中下一条指令的地址！

- 于是，程序并没有跳到外部库，而是又跳回了 PLT 继续往下执行。

- 接下来的 PLT 代码会将当前函数的 ID（表明是求 `puts` 的地址）压入栈中，并跳转到动态链接器（`_dl_runtime_resolve`）。

`动态链接器大显神威，查找到 `puts` 的真实物理映射虚拟地址，将真实地址覆盖写入到 `GOT` 表对应的条目中，最后顺手把控制权交给真正的 `puts` 函数。

第二次及以后的调用（已解析）：

你的程序再次调用 puts@plt。

PLT 里的 jmp 指令去查 GOT 表。

此时 GOT 表里已经是刚刚填入的 puts 真实地址了。

CPU 直接跳转到真实的 puts 库代码中执行。没有任何额外的开销！

> [!Note]
> 总结一下：PLT 是跳板，GOT 是地址表。第一次跳板查表，表里装的是“查找服务”的地址，于是触发链接器填表；第二次跳板查表，表里已经是真实函数地址，直接起飞。这充分体现了计算机科学中一句名言：“任何问题都可以通过增加一个间接层来解决”。