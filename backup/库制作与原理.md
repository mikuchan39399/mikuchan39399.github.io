## 1 库
库是提供特定功能的，成熟的可复用的代码，printf 函数就是C语言的`标准库`函数，库的重要性不言而喻。
- 静态库 `Linux - .a`    `Windows - .lib`
- 动态库 `Linux - .so`  `Windows - .dll`

> [!Note]
> 库本质上也是一种可执行代码的二进制形式，可以被操作系统拉到内存中执行
### 1.1 静态库
静态库本质就是**一些可重定向文件的集合**，所以在操作系统看来一个可执行文件有没有使用静态库是没有任何影响的
> [!Note]
> 一个可执行程序可能混合依赖静态库和动态库，编译默认动态链接库，只有找不到对应动态库时才会静态链接同名静态库，gcc 的 -`-static`选项可以强制优先静态链接静态库
#### 生成静态库
1. 将 C 源码编译为目标文件  `gcc -c 源文件.c`
2. 使用 GNU 的归档工具 ar，将多个 .o 文件打包成一个文件  `ar -rc libmystdio.a my_stdio.o my_string.o`
3. 生成后可以使用 ar 工具查看库里面包含的 .o 文件  `ar -tv libmystdio.a`
- `-t`：显示压缩包/归档文件中的内容列表。
- `-v`：显示详细信息。
#### 使用静态库
若可执行程序依赖某个静态库，则需要在编译时指明：
- `-l` 指定库名，去掉文件后缀与`lib`前缀即为库名
- `-I` 指定头文件搜索路径
- `-L` 指定库路径
### 1.2 动态库
如果程序依赖动态库，则程序`运行时`需要链接动态库
- 在程序运行之前加载动态库进内存并使用页表映射的过程被称作`动态链接`
- 把动态库加载进内存只需要加载程序用到的其中函数的地址，而不是函数所在目标文件的所有机器码
- 若多个进程程序都需要使用同一动态库，相比于臃肿的静态库，动态库只需要被加载进物理内存一份，每个进程的页表自己去映射虚拟地址就行了，节省了内存空间
#### 生成动态库
1. 将 C 源码编译为“位置无关”的目标文件
   - `gcc -fPIC -c 源文件.c`
   - `-fPIC` 生成位置无关代码
2. 链接生成动态库
   - `gcc -o libmystdio.so my_stdio.o my_string.o -shared`
   - `-shared` 表示生成共享库格式，也就是动态库格式
3. 运行时搜索动态库目录
   - 拷⻉ `动态库` ⽂件到系统共享库路径下,⼀般指 `/usr/lib`、`/usr/local/lib`、`/lib64` 或者开篇指明的库路径等
   - 向**系统**动态库路径下提供库同名软链接
   - 更改 `LD_LIBRARY_PATH` 环境变量
## 2. ELF文件
以下四种文件皆为`ELF`格式文件
- 可重定位文件/目标文件 `xxx.o`
- 可执行文件
- 动态库文件 `xxx.so`
- 内核转储
### 2.1 介绍ELF格式
```ascii
+----------------------------------+
|                                  |
|            ELF Header            |
|                                  |
+----------------------------------+
|                                  |
|    Program Header Table          |
|                                  |
+----------------------------------+
|                                  |
|            Section 1             |
|                                  |
+----------------------------------+
|                                  |
|            Section 2             |
|                                  |
+----------------------------------+
|                                  |
|               ...                |
|                                  |
+----------------------------------+
|                                  |
|            Section n             |
|                                  |
+----------------------------------+
|                                  |
|       Section Header Table       |
|                                  |
+----------------------------------+
```
` ELF Header` 中存储着整个ELF文件的相关信息，文件类型，机器类型，版本，`入口地址`，节头表与段头表的位置与大小等等
可以用`readelf -h xxx` 来查看一个ELF文件的文件头信息

<img width="939" height="558" alt="Image" src="https://github.com/user-attachments/assets/c1ea4ee4-743e-465e-95e6-d03332600234" />

### 2.2 节头表
将多个目标文件链接成可执行文件的过程需要节头表
也就是说编译器在链接时需要节头表以合并这些目标文件的节
**什么是节？**
还记得程序地址空间的内容吗？
- `.text`节 - 存放可执行的指令/代码
- `.data`节 - 存放已初始化的全局变量
- `.bss`节 - 存放未初始化的全局变量
- `.rodata` 节 - 存放只读数据区，例如字符串常量
这种细致的分类，让链接可以方便地合并不同的目标文件，合并同类型的节
`readelf -S a.out` 可用来查看可执行程序的节
```
whf@iZ7xvhr9e4wz4wpzicdcfgZ:~/workstaff/linux1/system_part/template$ readelf -S a
There are 31 section headers, starting at offset 0x39a8:

节头：
  [号] 名称              类型             地址              偏移量
       大小              全体大小          旗标   链接   信息   对齐
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .interp           PROGBITS         0000000000000318  00000318
       000000000000001c  0000000000000000   A       0     0     1
  [ 2] .note.gnu.pr[...] NOTE             0000000000000338  00000338
       0000000000000030  0000000000000000   A       0     0     8
  [ 3] .note.gnu.bu[...] NOTE             0000000000000368  00000368
       0000000000000024  0000000000000000   A       0     0     4
  [ 4] .note.ABI-tag     NOTE             000000000000038c  0000038c
       0000000000000020  0000000000000000   A       0     0     4
  [ 5] .gnu.hash         GNU_HASH         00000000000003b0  000003b0
       0000000000000028  0000000000000000   A       6     0     8
  [ 6] .dynsym           DYNSYM           00000000000003d8  000003d8
       0000000000000120  0000000000000018   A       7     1     8
  [ 7] .dynstr           STRTAB           00000000000004f8  000004f8
       000000000000016c  0000000000000000   A       0     0     1
  [ 8] .gnu.version      VERSYM           0000000000000664  00000664
       0000000000000018  0000000000000002   A       6     0     2
  [ 9] .gnu.version_r    VERNEED          0000000000000680  00000680
       0000000000000070  0000000000000000   A       7     2     8
  [10] .rela.dyn         RELA             00000000000006f0  000006f0
       00000000000000d8  0000000000000018   A       6     0     8
  [11] .rela.plt         RELA             00000000000007c8  000007c8
       0000000000000060  0000000000000018  AI       6    24     8
  [12] .init             PROGBITS         0000000000001000  00001000
       000000000000001b  0000000000000000  AX       0     0     4
  [13] .plt              PROGBITS         0000000000001020  00001020
       0000000000000050  0000000000000010  AX       0     0     16
  [14] .plt.got          PROGBITS         0000000000001070  00001070
       0000000000000010  0000000000000010  AX       0     0     16
  [15] .plt.sec          PROGBITS         0000000000001080  00001080
       0000000000000040  0000000000000010  AX       0     0     16
  [16] .text             PROGBITS         00000000000010c0  000010c0
       000000000000026e  0000000000000000  AX       0     0     16
  [17] .fini             PROGBITS         0000000000001330  00001330
       000000000000000d  0000000000000000  AX       0     0     4
  [18] .rodata           PROGBITS         0000000000002000  00002000
       0000000000000023  0000000000000000   A       0     0     4
  [19] .eh_frame_hdr     PROGBITS         0000000000002024  00002024
       0000000000000054  0000000000000000   A       0     0     4
  [20] .eh_frame         PROGBITS         0000000000002078  00002078
       0000000000000130  0000000000000000   A       0     0     8
  [21] .init_array       INIT_ARRAY       0000000000003d90  00002d90
       0000000000000008  0000000000000008  WA       0     0     8
  [22] .fini_array       FINI_ARRAY       0000000000003d98  00002d98
       0000000000000008  0000000000000008  WA       0     0     8
  [23] .dynamic          DYNAMIC          0000000000003da0  00002da0
       0000000000000200  0000000000000010  WA       7     0     8
  [24] .got              PROGBITS         0000000000003fa0  00002fa0
       0000000000000060  0000000000000008  WA       0     0     8
  [25] .data             PROGBITS         0000000000004000  00003000
       0000000000000010  0000000000000000  WA       0     0     8
  [26] .bss              NOBITS           0000000000004040  00003010
       0000000000000118  0000000000000000  WA       0     0     64
  [27] .comment          PROGBITS         0000000000000000  00003010
       000000000000002b  0000000000000001  MS       0     0     1
  [28] .symtab           SYMTAB           0000000000000000  00003040
       0000000000000498  0000000000000018          29    21     8
  [29] .strtab           STRTAB           0000000000000000  000034d8
       00000000000003b2  0000000000000000           0     0     1
  [30] .shstrtab         STRTAB           0000000000000000  0000388a
       000000000000011a  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), l (large), p (processor specific)
```
### 2.3 程序头表
操作系统在加载时，如果按照最小单位为节去分配内存的话，我们知道操作系统内存管理与磁盘IO的最小单位为`4KB`，这样会极大地浪费内存，所以操作系统在把ELF文件拉进内存时还会做进一步合并成**段**，这个过程需要用到程序头表
**什么是段？**
当程序运行时，操作系统并不关心这块数据具体是全局变量还是字符串常量，它只关心这块内存的访问权限。
- 可读吗？
- 可写吗？
- 可执行吗？
所以，一个段是由一个或者多个具有相同访问权限的节合并的，合并同类项，比如：
- 比如，`.text` 节（只读、可执行）和 `.rodata`节（只读）会被打包进同一个 `Text` 段（可读、可执行：R E）
- `.data` 节和 `.bss` 节会被打包进同一个 `Data` 段（可读、可写：R W）。
程序头表在链接器合并完节后顺手根据访问权限生成程序头表，指导操作系统以段加载ELF进内存


## 3. 深入链接与加载
### 3.1 逻辑地址
进程`mm_struct`->`vm_area_struct`在进程刚刚创建的时候，初始化数据从哪⾥来的？
- 我们可以用`objdump -S`反汇编一下可执行文件
```
whf@iZ7xvhr9e4wz4wpzicdcfgZ:~/workstaff/linux1/system_part/template$  objdump -S a

a：     文件格式 elf64-x86-64


Disassembly of section .init:

0000000000001000 <_init>:
    1000:       f3 0f 1e fa             endbr64
    1004:       48 83 ec 08             sub    $0x8,%rsp
    1008:       48 8b 05 e1 2f 00 00    mov    0x2fe1(%rip),%rax        # 3ff0 <__gmon_start__@Base>
    100f:       48 85 c0                test   %rax,%rax
    1012:       74 02                   je     1016 <_init+0x16>
    1014:       ff d0                   call   *%rax
    1016:       48 83 c4 08             add    $0x8,%rsp
    101a:       c3                      ret
......
```
> 我们会发现一个ELF文件在被加载进内存之前就已经拥有虚拟地址了，就是最左边那一列
> 我们把ELF中的虚拟地址称作**逻辑地址/偏移量**，这与后面要讲的`PIC`位置无关代码关系很大
回答开篇的问题：操作系统在加载程序时，会解析 ELF 文件中的程序头表。程序头表中详细记录了各个**段**的预期逻辑地址、长度以及访问权限。

操作系统正是提取了这些段信息，来实例化并初始化进程的 vm_area_struct 结构体。
> [!Note]
> 所以虚拟地址这个概念需要操作系统与编译器互相协同支持
### 3.2 CPU硬件支持虚拟地址
在操作系统把ELF可执行文件加载进内存之后，应该交由CPU执行程序，而所有ELF文件全都是逻辑地址编址过的，也就是说CPU也要支持虚拟地址
- CPU中有着这两个寄存器：
   - `EIP` 程序计数器
   - `CR3` 页目录基址寄存器
- 和一个CPU内部硬件模块`MMU`
### 3.3 动态库加载
### 3.4 动态链接