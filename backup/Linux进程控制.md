## 进程创建
在Linux中，fork() 函数用于创建新进程，调用函数的进程为父进程，新进程则为他的子进程
它存在于 unist.h 头文件中(POSIX 标准)
当一个进程执行 fork 后，系统会分配新的PCB，将父进程部分数据结构内容拷贝给子进程，并添加子进程至系统进程列表中。
### fork 返回值
- 父进程：子进程的 pid
- 子进程：0
- 出错：-1 , 且子进程不会被创建
调用 fork 后，父进程与子进程的二进制代码相同，他们准备退出 fork 函数时，**两个独立的执行流为返回值返回了不同的值并各自独立**，这也是为什么一个 fork 函数的返回值会有两个不同的值。
### 写时拷贝
子进程刚被创建出来时，虚拟地址空间完全继承于父进程，所以子进程与父进程所有数据的虚拟地址相同且指向同一物理内存
直到其中某个进程中的数据被写入时，此时两进程的数据必须被区分开了，这时候物理内存才会另开辟一份并且往里拷贝一份一摸一样的数据，再修改那个被写入的进程的虚拟地址在页表中映射向新的物理内存，这就叫写时拷贝。
写时拷贝体现了进程管理与物理内存解耦合的优越性，提高了内存分配的效率，避免上层频繁创建进程带来的无意义性能消耗
> 举一反三地讲，使用malloc等函数开辟堆区空间时，只要不使用这块内存，当然不会给上层分配物理内存的，许可证和实际发放是两回事，解耦合

## 进程终止
进程退出的场景分为三种：
1. 代码运行完毕，结果正确
2. 代码运行完毕，结果不正确
3. 代码异常，被操作系统发送信号杀死

退出进程的方法：
1. 在 main 函数中 return
2. 在任意位置调用 exit 及系列函数
3. 向进程发送对应信号，例如 kill 命令行指令和 Ctrl + C

### exit 与 _exit
这两个函数都可用于退出当前进程，他们的区别在于
- _exit 函数是系统调用，他会直截了当地退出当前进程
- exit 函数是上层库函数，他会先刷新缓冲区再退出
> 这也说明所谓的缓冲区也是上层语言定义的而非操作系统

### 退出码与信号
- 代码运行完毕时进程退出会产生退出码，用于检查结果的正确与否
- 而代码异常时，结果已经不重要了，这时候只需要知道系统发送给异常进程的信号从而确定程序异常的原因

## 进程等待
### 进程等待的作用
- 解决僵尸进程的问题，防止内存泄露
- 父进程通过进程等待回收子进程的资源
- 父进程可以通过进程等待获取子进程的退出信息，父进程需要知道子进程任务完成得怎么样，结果对还是不对，有没有异常？
### 进程等待的方法
#### wait
```cpp
#include <sys/types.h>
#incldue <sys/wait.h>

pid_t wait(int* status)
```
- 返回值：
   - 成功：返回被等待进程 pid
   - 失败：返回 -1 并产生 errno
- 参数：
   - 输出型参数 status：用于提取子进程退出状态，设置NULL以弃用此功能
> [!NOTE]
> 这个接口一旦调用，父进程会一直尝试等待任意一个子进程退出，这就是阻塞等待，如果你创建了十个子进程，你便需要循环调用十次 wait，这样才能防止产生僵尸进程

#### waitpid
```cpp
#include <sys/types.h>
#incldue <sys/wait.h>

pid_t waitpid(pid_t pid, int *status, int options)
```
- 返回值：
   - 成功：返回被等待进程 pid
   - 失败：返回 -1 并产生 errno
   - 选项设置为 非阻塞模式：当调用时指定进程没有退出时，返回 0
- 参数
   - pid：需要被指定等待的 进程id
   - status：与 wait 相同
   - options：
      - 默认为 0，表示阻塞等待
      - WNOHANG：非阻塞等待模式
> [!NOTE]
> 当使用 wait 且无子进程 或 使用 waitpid 却无对应 pid 进程存在时，wait/waitpid 会直接失败
> 当一个子进程已经退出后再调用 wait/waitpid 时，它们会立即返回并执行相应回收操作

#### 子进程 status
若在 wait/waitpid 中启用此输出型参数，父进程就可以从其中提取出子进程退出的信息
status 是一个三十二位无符号整数位图
- 正常退出：后十六位弃用，前八位为 0， 中间 8 ~ 15 比特位为进程退出码
- 异常终止：后二十四位弃用，0 ~ 6位为信号，第八位为 Core Dump 标志位
> [!NOTE]
> 最好不要写自己写位运算来判断，这里有现成的标准宏运算可以直接拿来用
> WIFEXITED(status) 用于判断子进程是否正常退出
> WEXITSTATUS(status) 提取 status 中子进程的退出码，只有子进程正常退出这个宏才有意义
> WIFSIGNALED(status) 用于判断子进程是否因异常而被系统信号所杀
> WTERMSIG(status) 提取杀死子进程的信号编号
> WCOREDUMP(status) 判断是否生成 Core Dump 文件，常常被用于调试段错误

## 进程程序替换

## Demo Shell