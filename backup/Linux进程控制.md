## 进程创建
在Linux中，fork() 函数用于创建新进程，调用函数的进程为父进程，新进程则为他的子进程
它存在于 unist.h 头文件中(POSIX 标准)
当一个进程执行 fork 后，系统会分配新的PCB，将父进程部分数据结构内容拷贝给子进程，并添加子进程至系统进程列表中。
### fork 返回值
- 父进程：子进程的 pid
- 子进程：0
- 出错：-1 , 且子进程不会被创建
调用 fork 后，父进程与子进程的二进制代码相同，他们准备退出 fork 函数时，**两个独立的执行流为返回值返回了不同的值并各自独立**，这也是为什么一个 fork 函数的返回值会有两个不同的值，。
### 写时拷贝
子进程刚被创建出来时，虚拟地址空间完全继承于父进程，所以子进程与父进程所有数据的虚拟地址相同且指向同一物理内存
直到其中某个进程中的数据被写入时，此时两进程的数据必须被区分开了，这时候物理内存才会另开辟一份并且往里拷贝一份一摸一样的数据，再修改那个被写入的进程的虚拟地址在页表中映射向新的物理内存，这就叫写时拷贝。
写时拷贝体现了进程管理与物理内存解耦合的优越性，提高了内存分配的效率，避免上层频繁创建进程带来的无意义性能消耗
> 举一反三地讲，使用malloc等函数开辟堆区空间时，只要不使用这块内存，当然不会给上层分配物理内存的，许可证和实际发放是两回事，解耦合

## 进程终止
进程退出的场景分为三种：
1. 代码运行完毕，结果正确
2. 代码运行完毕，结果不正确
3. 代码异常，被操作系统发送信号杀死

退出进程的方法：
1. 在 main 函数中 return
2. 在任意位置调用 exit 及系列函数
3. 向进程发送对应信号，例如 kill 命令行指令和 Ctrl + C

### exit 与 _exit
这两个函数都可用于退出当前进程，他们的区别在于
- _exit 函数是系统调用，他会直截了当地退出当前进程
- exit 函数是上层库函数，他会先刷新缓冲区再退出
> 这也说明所谓的缓冲区也是上层语言定义的而非操作系统

### 退出码与信号
- 代码运行完毕时进程退出会产生退出码，用于检查结果的正确与否
- 而代码异常时，结果已经不重要了，这时候只需要知道系统发送给异常进程的信号从而确定程序异常的原因

## 进程等待
### 进程等待的作用
- 解决僵尸进程的问题，防止内存泄露
- 父进程通过进程等待回收子进程的资源
- 父进程可以通过进程等待获取子进程的退出信息，父进程需要知道子进程任务完成得怎么样，结果对还是不对，有没有异常？
### 进程等待的方法
#### wait
```cpp
#include <sys/types.h>
#incldue <sys/wait.h>

pid_t wait(int* status)
```
- 返回值：
   - 成功：返回被等待进程 pid
   - 失败：返回 -1
- 参数：
   - 输出型参数：用于提取子进程退出状态，设置NULL以弃用此功能
  
## 进程程序替换
## Demo Shell