
## 进程
### 基本概念
在操作系统学科中, 进程被视作一个程序被加载进内存的执行实例
在Linux内核中, 进程被视作承担分配系统资源调配的同一单位, 且 进程之间存在隔离性

#### PCB
PCB, 又叫做进程控制块, 在操作系统学科中是描述进程的信息集合体
在Linux内核中, PCB被落地为具体的 task_struct 结构体
Linux中的进程 相当于 被加载进内存的 task_struct 与具体的代码和数据

#### 组织进程
Linux中以双链表的形式组织管理着 task_struct 以管理进程, 而不用关心具体的代码数据
其中, Linux采用侵入式数据结构的设计来让 task_struct 灵活的被挂载进多个数据结构中
例如双链表, task_struct 中有一个结点 list_head 用于双链表的链接
```cpp
struct list_head 
{
    struct list_head *next;
    struct list_head *prev;
};

//PCB
struct task_struct 
{
    // ... 其他属性 ...
    struct list_head tasks; // 嵌入的双链表节点
    // ... 其他属性 ...
};
```
这样 task_struct 就能通过这个结点找到其他 task_struct 内部的 list_node.
根据C语言的指针运算, 就能通过下面这个偏移量方法用内部指针找到整个 task_struct 的起始指针来访问进程的所有信息
```cpp
struct task_struct *p = (struct task_struct *) ( 
    (char *)ptr - (unsigned long) &((struct task_struct *)0)->tasks 
);
```
由此可见, 侵入式数据结构的设计能让 task_struct 不需要复制自身就能方便地插入进很多数据结构, 只要为其添加新的节点即可, 是很优秀的设计
### 基本操作
#### 查看进程
要查看系统目前的进程信息, 可以用ls 命令查询/proc/(具体的进程pid)来查看
```bash
# 列出进程相关的属性文件
ls /proc/3939

# 查看进程的详细状态信息
cat /proc/3939/status
```
虽然其中并不存在具体的文件存入磁盘, 只是内核以文件的形式动态地呈现进程信息给用户, 但这体现了Linux一切皆文件的特性
当然大多数进程信息同样也可以用 top 和 ps 这些用户级工具来获取
#### 创建进程-fork系统接口
fork是Linux的unistd.h所包含的系统接口, 调用后以运行程序的进程为父进程产生一个独立的子进程
若fork成功, 父进程的fork返回值为子进程的pid, 子进程的fork返回值为0
若fork失败, 不产生子进程, fork返回值为-1
所以可以用分支语句根据返回值来区分父子进程

#### 进程工作目录
Linux 中每个进程都有一个当前工作目录（cwd），被作为进程信息的一部分存储在PCB里，具体是fs_struct指针
子进程的cwd默认继承父进程，而由命令行工具bash所创建的进程的父进程全都是bash自己。
所以， 进程的cwd默认是使用bash的目录
在程序中使用chdir(const char *path)系统接口可以改变当前进程的工作目录
> [!NOTE]
> 所以我以前在写在本目录打开一个文件的时候，如果不是绝对路径，相对路径的话就会在前面贴上cwd

## 进程状态
Linux中进程有如下几个状态, 以下状态在kernel源码中被定义：

```cpp
static const char *const task_state_array[] = 
{
    "R (running)", /*0 */
    "S (sleeping)", /*1 */
    "D (disk sleep)", /*2 */
    "T (stopped)", /*4 */
    "t (tracing stop)", /*8 */
    "X (dead)", /*16 */
    "Z (zombie)", /*32 */
};
```
| 状态符号 | 状态名称 | 英文名称 | 详细描述 |
| :---: | :--- | :--- | :--- |
| **R** | 运行状态 | Running | 并不意味着进程一定在运行中，它表明进程**要么是在运行中，要么在运行队列里**。 |
| **S** | 睡眠状态 | Sleeping | 意味着进程在等待事件完成。这里的睡眠有时候也叫做**可中断睡眠** (interruptible sleep)。 | 
| **D** | 磁盘休眠状态 | Disk Sleep | 有时候也叫**不可中断睡眠状态** (uninterruptible sleep)，在这个状态的进程通常会**等待 I/O 的结束**。 |
| **T** | 停止状态 | Stopped | 可以通过发送 `SIGSTOP` 信号给进程来停止 (T) 进程。这个被暂停的进程可以通过发送 `SIGCONT` 信号让进程继续运行。 |
| **t** | 追踪停止状态 | tracing stop | 使用断点调试时会触发的进程状态 | 
| **X** | 死亡状态 | Dead | 这个状态只是一个返回状态，你**不会在任务列表里看到这个状态**。 |
| **Z** | 僵尸状态 | Zombie | 当进程退出并且父进程（使用 `wait` 相关系统调用）没有读取到子进程退出的返回代码时就会产生僵死进程。 |
> [!NOTE]
> 当父进程早于子进程退出时, 子进程会被 init 进程领养, 成为孤儿进程, 孤儿进程可以是任何状态, 属于正常现象
> 僵死进程会以终⽌状态保持在进程表中，并且会⼀直在等待⽗进程读取退出状态代码。
> 直到父进程退出，僵尸进程会被 init 进程 (pid=1) 领养。Init 进程会立即执行回收操作，将该僵尸进程彻底释放。

> [!WARNING]
> 僵死进程会挤占内存的PCB资源, 并且会导致内存泄露, 注意父进程一定要使用wait相关系统接口

上文提到过，Linux采取管理 task_struct 的方式来组织管理与之对应的进程
每一个 CPU 都配备一个运行队列 struct rq。 进程的 task_struct 通过内部的节点（链表节点或红黑树节点），把自己挂载到 CPU 的 runqueue 中。
```cpp
// 现代CFS调度器实际采用红黑树等复杂结构维护
struct runqueue
{
     int num;
     struct list_head node;
};
```
可以看到，这里承接了上文提到的侵入式设计，运行队列采用双链表形式实现
在操作系统学科的语境中：
进程被扔进CPU中才叫运行状态，进程处于 runqueue 中属于就绪状态
当一个进程的程序在等待键盘等IO设备数据就绪的过程中，操作系统肯定不会让这个进程占在运行队列里占用CPU计算资源
os会把这个进程弹出运行队列，塞进对应硬件设备的阻塞队列中，让进程在那里等待IO设备的数据，此时进程状态为阻塞状态
> 在Linux中，此时进程为S状态，也就是浅度睡眠状态，此状态的进程允许 os 动手动脚，例如为了自保杀掉它

当内存资源吃紧时，os 可能会把阻塞状态的进程的数据 swap 进磁盘（磁盘拥有专门的swap小分区干这件事）
此时的进程状态为阻塞挂起状态
在极端情况下 os 也可能把就绪状态的进程也挂起，此时的进程状态为就绪挂起状态
> 注意PCB无论如何都必须待在内存里，这是 os 找回进程的唯一途径

在Linux落地时，发现如果进程正在处于挂起状态时 os 可能因为自保删掉正在挂起的进程PCB，内存泄露，各种麻烦事就来了
所以，Linux中禁止 os 更改正在挂起的进程
> [!IMPORTANT]
> **关于挂起与 D 状态的误区**
> 操作系统理论中提到的“挂起状态”，在 Linux 状态机中并没有直接对应的单一状态。
> **D 状态 (Disk Sleep)** 的真正含义是 **不可中断的硬件等待**。它是为了保证在关键 I/O 操作期间（如磁盘读写），进程不会被信号打断，从而避免硬件数据损坏。它与内存是否 swap 无绝对关联。


## 进程优先级
进程优先级就是在一次进程调度周期内局部决定CPU执行进程顺序的数字，作为进程信息自然存在 task_struct 中
这里有两个变量，分别是 PRI 和 NI
PRI 为默认的一个定值, NI 的 取值范围是 -20 <= NI <= 19
最终的优先级决策数是 PRI + NI，这个数越小则越早被CPU执行
有多种办法可以手动干预进程的NI值，例如 top 工具，nice/renice 命令，setpriority系统接口
不过一般用的很少我感觉

## 进程切换与调度
### 补充概念-竞争、独⽴、并⾏、并发
竞争性：系统进程数⽬众多，⽽CPU资源只有少量，甚⾄1个，所以进程之间是具有竞争属性的。为
了⾼效完成任务，更合理竞争相关资源，便具有了优先级
独⽴性：多进程运⾏，需要独享各种资源，多进程运⾏期间互不⼲扰
并⾏：多个进程在多个CPU下分别，同时进⾏运⾏，这称之为并⾏
并发：多个进程在⼀个CPU下采⽤**进程切换**的⽅式，在⼀段时间之内，让多个进程都得以推进，称
之为并发
### 进程切换
进程在CPU上的切换无疑是很频繁的，而进程被扔进CPU计算处理时，进程的代码与数据会被放在CPU的一套寄存器中
所以进程被切换走时必须要保留自己的这些家当，腾空给其他进程使用寄存器，这就是进程切换时对自己硬件上下文的保存
在Linux中硬件上下文保存在 tss_struct 中，同样能在task_struct 中找到，它负责硬件上下文的保存与恢复
### 进程调度
> [!NOTE]
> Linux中的运行队列就是就绪队列，调度队列为一个抽象概念无直接对应结构体
<img width="554" height="684" alt="Image" src="https://github.com/user-attachments/assets/60436f56-fc25-412d-99c7-74c0d60ad2f3" />


上图中可以看到，一个 rq 结构体里存在着两套队列，一套活跃队列，一套过期队列
其中还有 active* 指针指向活跃队列结点，expired* 指针指向过期队列结点
bitmap是位图，利用二进制特性反映队列的盈余状况，无需遍历队列数组
优先级只在两套队列内部发挥局部作用，所以不会导致饥饿问题
当活跃队列中进程为空，所有进程都已过期后，只需交换 active* 指针和 expired* 指针即可实现O(1)调度算法
也是很优秀的设计
可以注意到两套队列中队列都有140个（0 ~ 139），quene[140]
我们不关心实时优先级（0 ~ 99），只关心普通优先级（100 ~ 139），这与nice值（NI）的取值范围相对应
队列的数组下标就对应着优先级
