## 回顾 C 语言程序地址空间
> 从低地址开始，到高地址……
> 首先，我们来看三个最基本的静态区域！
### 1. 正文代码区 (.text / .rodata)
该区域对应于编译后的机器指令
- 它存放着：
   - 机器代码：也就是 CPU 执行的二进制指令，高级语言中所写的 if-else / while / for 与函数调用等逻辑，编译后都在这里
   - 只读常量：存放 字符串字面量 以及 const 修饰的 全局变量
- 特点：
   - 只读：防止程序运行修改指令
   - 共享：一个程序创建子进程的话，父子进程之间共享这段代码段，节省内存
   - 位置：位于程序地址空间最底层
```cpp
// --- (.text / .rodata) ---
const int g_const = 100;
char *str = "Hello"; //实际上，字符串字面量"Hello"存在于.rodata中，指针变量 str 作为普通变量存在于其他区域中
```
> 在具体的操作系统中，.text 通常专门存放机器代码，.rodata 专门存放只读常量

### 2. 初始化数据区 (.data)
这个区域存放的是程序启动时就已经确定数值的变量
- 它存放着：
   - 显式初始化为非零值的 全局变量
   - 显式初始化为非零值的 static 修饰的静态变量
- 特点：
   - 读写：程序运行过程中允许对此区域进行读取修改
   - 占用文件空间：这些变量初始值存在于可执行文件 (exe / elf)，程序运行时将它们从磁盘拷贝至内存

```cpp
// --- (.data) ---
int g_var = 10;
static int s_var = 20;
```
 ### 3. 未初始化数据区 (.bss)
这个区域的名字来源于汇编语言时代的 "Block Started by Symbol"
- 它存放着：
   - 显式初始化为零值 或 没有初始化的 全局变量
   - 显式初始化为零值 或 没有初始化的 static 修饰的 静态变量
- 特点：
   - 自动清零： 操作系统在加载程序时，会将这块内存全部置为 0。这也是为什么全局变量不赋值默认是 0。
   - 不占文件空间： 这是它存在的最大意义。比如我定义了一个 int arr[10000]; 的全局数组且没赋值，可执行文件不会因此变大 40KB。可执行文件只需要记录“这里需要预留 40KB 的空间”这个信息即可。

```cpp
// --- (.bss) ---
int g_bss;
int g_zero = 0; 
static int s_bss;
```
> 接下来是与用户关联较大的...
### 堆栈
堆区与栈区相对而生，口头上提到堆栈区时没有特别说明的话默认指栈区
严谨讨论时最好把他们两个区分开
堆区从堆栈区低位开始延展至高位，栈区从堆栈区高位开始延展至低位

#### 栈区与函数栈帧
当一个函数被调用时，程序通过移动栈指针 (编译器生成的指令 + CPU 改变栈指针) 在栈上划出一段空间，形成函数栈帧（OS 提供栈映射与保护）
事实上，栈区就是由一个个函数栈帧堆叠而成的
它是一个复杂的结构体，
- 包含：
   - 函数中定义的局部变量 (不包括静态变量)
   - 调用函数时传入的参数 (这个也有可能在寄存器之间传递不放进栈帧)
   - 返回地址：函数调用完毕之后程序应当跳转到哪里继续执行
   - 旧的栈底指针 EBP / RBP：用于找到**在栈区弹出该栈帧时应该回到的上一个栈帧**的底部位置
   - 保存的寄存器：函数执行过程中需要用到寄存器，为了不覆盖调用者的数据，需要先把寄存器里的(属于调用者)的旧值存在栈帧里，用完了再恢复 
   > 一般操作系统会给栈区规定好一个较小的空间大小，例如8MB，栈区超过这个范围则会栈溢出
#### 堆区与用户内存管理
堆区，
- 它存放：
   - 程序员使用高级语言的各种接口向操作系统申请的内存，例如 C 的malloc和 C++ 的 new
- 特点：
   - 由程序员显式申请/释放，不使用 free 等接口释放内存的话会导致内存泄露
   - 空间相较与栈区会大很多
 > 堆区和栈区两面包夹芝士中间还有一块空白区，被称作共享区 (mmap 映射区)，用于加载动态库(.so / .dll) 或进行文件映射
 > 栈区的更高位还有一块用户空间专门用于存放启动程序时传入的命令行参数与环境变量，再往上就是留给内核的部分了
### 引入虚拟地址空间
> 有句话告诉我们，操作系统是对于计算机硬件的最底层抽象，学习 C语言时接触的这些地址与指针，真的是计算机物理上确确实实的地址吗......当然不是~
```cpp

```
